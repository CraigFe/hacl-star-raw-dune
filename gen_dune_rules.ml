open Astring

(* let header_files () =
 *   [
 *     "Hacl_AES128.h";
 *     "Hacl_AES.h";
 *     "Hacl_Bignum25519_51.h";
 *     "Hacl_Bignum256.h";
 *     "Hacl_Bignum4096.h";
 *     "Hacl_Bignum.h";
 *     "Hacl_Blake2b_256.h";
 *     "Hacl_Blake2b_32.h";
 *     "Hacl_Blake2s_128.h";
 *     "Hacl_Blake2s_32.h";
 *     "Hacl_Chacha20.h";
 *     "Hacl_Chacha20Poly1305_128.h";
 *     "Hacl_Chacha20Poly1305_256.h";
 *     "Hacl_Chacha20Poly1305_32.h";
 *     "Hacl_Chacha20_Vec128.h";
 *     "Hacl_Chacha20_Vec256.h";
 *     "Hacl_Chacha20_Vec32.h";
 *     "Hacl_Curve25519_51.h";
 *     "Hacl_Curve25519_64.h";
 *     "Hacl_Curve25519_64_Slow.h";
 *     "Hacl_EC_Ed25519.h";
 *     "Hacl_Ed25519.h";
 *     "Hacl_FFDHE4096.h";
 *     "Hacl_FFDHE.h";
 *     "Hacl_Frodo1344.h";
 *     "Hacl_Frodo640.h";
 *     "Hacl_Frodo64.h";
 *     "Hacl_Frodo976.h";
 *     "Hacl_Frodo_KEM.h";
 *     "Hacl_Hash.h";
 *     "Hacl_HKDF_Blake2b_256.h";
 *     "Hacl_HKDF_Blake2s_128.h";
 *     "Hacl_HKDF.h";
 *     "Hacl_HMAC_Blake2b_256.h";
 *     "Hacl_HMAC_Blake2s_128.h";
 *     "Hacl_HMAC_DRBG.h";
 *     "Hacl_HMAC.h";
 *     "Hacl_HPKE_Curve51_CP128_SHA256.h";
 *     "Hacl_HPKE_Curve51_CP128_SHA512.h";
 *     "Hacl_HPKE_Curve51_CP256_SHA256.h";
 *     "Hacl_HPKE_Curve51_CP256_SHA512.h";
 *     "Hacl_HPKE_Curve51_CP32_SHA256.h";
 *     "Hacl_HPKE_Curve51_CP32_SHA512.h";
 *     "Hacl_HPKE_Curve64_CP128_SHA256.h";
 *     "Hacl_HPKE_Curve64_CP128_SHA512.h";
 *     "Hacl_HPKE_Curve64_CP256_SHA256.h";
 *     "Hacl_HPKE_Curve64_CP256_SHA512.h";
 *     "Hacl_HPKE_Curve64_CP32_SHA256.h";
 *     "Hacl_HPKE_Curve64_CP32_SHA512.h";
 *     "Hacl_HPKE_P256_CP128_SHA256.h";
 *     "Hacl_HPKE_P256_CP256_SHA256.h";
 *     "Hacl_HPKE_P256_CP32_SHA256.h";
 *     "Hacl_Impl_Blake2_Constants.h";
 *     "Hacl_Impl_Blake2.h";
 *     "Hacl_Impl_FFDHE_Constants.h";
 *     "Hacl_IntTypes_Intrinsics.h";
 *     "Hacl_Kremlib.h";
 *     "Hacl_NaCl.h";
 *     "Hacl_P256.h";
 *     "Hacl_Poly1305_128.h";
 *     "Hacl_Poly1305_256.h";
 *     "Hacl_Poly1305_32.h";
 *     "Hacl_RSAPSS2048_SHA256.h";
 *     "Hacl_RSAPSS.h";
 *     "Hacl_Salsa20.h";
 *     "Hacl_SHA3.h";
 *     "Hacl_Spec.h";
 *     "Hacl_Streaming_Blake2b_256.h";
 *     "Hacl_Streaming_Blake2.h";
 *     "Hacl_Streaming_Blake2s_128.h";
 *     "Hacl_Streaming_MD5.h";
 *     "Hacl_Streaming_Poly1305_128.h";
 *     "Hacl_Streaming_Poly1305_256.h";
 *     "Hacl_Streaming_Poly1305_32.h";
 *     "Hacl_Streaming_SHA1.h";
 *     "Hacl_Streaming_SHA2.h";
 *   ]
 *   |> List.iter (fun x ->
 *          Printf.printf "(copy_files (alias header_files) (files ../%s))\n" x) *)

let print_header () =
  Format.printf "@[<v>;; This file was auto-generated by [%s]@,@,@]" __FILE__

type mode =
  | Lib_gen  (** Generate executable stanzas for the stub generators *)
  | Lib_bindings  (** Generate library stanzas each for the bindings *)
  | Lib

let generator_module_of_file x = x ^ "_gen"

let chop_suffix_opt name ~suffix =
  match Filename.check_suffix name suffix with
  | false -> None
  | true -> Some (Filename.chop_suffix name suffix)

let chop_suffix_exn name ~suffix =
  match chop_suffix_opt name ~suffix with
  | Some s -> s
  | None ->
      Format.kasprintf failwith "File %s doesn't have the expected suffix: %s"
        name suffix

let rec pp_list pp_elt ppf = function
  | [] -> ()
  | [ x ] -> pp_elt ppf x
  | x :: xs ->
      pp_elt ppf x;
      Format.pp_print_char ppf ' ';
      pp_list pp_elt ppf xs

let executable_name = Printf.sprintf "%s_gen"
let bindings_name = Printf.sprintf "%s_bindings"
let stubs_name = Printf.sprintf "%s_stubs"
let bindings_library_name = Printf.sprintf "hacl-star-raw.%s_bindings"
let stubs_library_name = Printf.sprintf "hacl-star-raw.%s_stubs"

let print_generator_stanzas =
  List.iter (fun name ->
      let executable_name = executable_name name in
      let library_name = bindings_library_name name in
      Format.printf
        "@[<v 1>(executable@,\
         (name %s)@,\
         (modules %s)@,\
         (libraries ctypes ctypes.stubs %s))@]@.@." executable_name
        executable_name library_name)

let print_library_stanzas deps =
  List.iter (fun name ->
      (* Printf.eprintf "Trying to find: %s\n%!" name; *)
      let deps = Hashtbl.find deps (bindings_library_name name) in
      Format.printf
        ";; ----------------------------------@.;; %s@.;; \
         ----------------------------------@.@.@[<v 1>(library@,\
         (name %s)@,\
         (modules %s)@,\
         (public_name %s)@,\
         (wrapped false)@,\
         (flags (:standard -w -27-33 -warn-error -A))@,\
         (libraries ctypes %a))@]@.@." name (bindings_name name)
        (bindings_name name)
        (bindings_library_name name)
        (pp_list Format.pp_print_string)
        deps;

      Format.printf
        "@[<v 1>(library@,\
         (name %s)@,\
         (modules %s)@,\
         (public_name %s)@,\
         (wrapped false)@,\
         @[<v 1>(foreign_stubs@,\
         (language c)@,\
         (names %s))@]@,\
         (libraries ctypes ctypes.stubs))@]@.@." (stubs_name name)
        (stubs_name name) (stubs_library_name name) (name ^ "_c_stubs");

      Format.printf
        "@[<v 1>(rule@,\
         (targets %s.ml)@,\
         @[<v 1>(action@,\
         @[<v 1>(with-stdout-to %%{targets}@,\
         @[<v 1>(chdir ../@,\
         (run lib_gen/%s.exe -ml)))))@]@]@]@]@.@." (stubs_name name)
        (executable_name name);

      Format.printf
        "@[<v 1>(rule@,\
         (targets %s.c)@,\
         @[<v 1>(action@,\
         @[<v 1>(with-stdout-to %%{targets}@,\
         @[<v 1>(chdir ../@,\
         (run lib_gen/%s.exe -c)))))@]@]@]@]@.@." (name ^ "_c_stubs")
        (executable_name name))

let read_dependencies path =
  let ic = Scanf.Scanning.open_in path in
  let () = Scanf.bscanf ic "%_s@\n" () in
  let depends = Hashtbl.create 0 in
  let lib_name n =
    try Scanf.sscanf n "lib/%s@.cmx" (fun x -> Some ("hacl-star-raw." ^ x)) with
    | Scanf.Scan_failure _ -> None
    | End_of_file -> None
  in
  let rec process_lines () =
    Scanf.bscanf ic "%s@\n" @@ fun line ->
    let line = line ^ "\n" in
    Scanf.sscanf line "%s@: %s@\n" @@ fun target deps ->
    (match lib_name target with
    | None -> ()
    | Some target ->
        let deps = String.fields deps |> List.filter_map lib_name in
        (* Format.eprintf "Scanning line: %s\n" line;
         * Format.eprintf "%s <- %a\n%!" target
         *   (pp_list Format.pp_print_string)
         *   deps; *)
        Hashtbl.add depends target deps);
    if not (Scanf.Scanning.end_of_input ic) then process_lines ()
  in
  process_lines ();
  depends

let () =
  let mode =
    match Sys.argv with
    | [| _; "--lib"; _ |] -> Lib
    | [| _; "--lib-bindings"; _ |] -> Lib_bindings
    | [| _; "--lib-gen"; _ |] -> Lib_gen
    | _ ->
        Format.eprintf "Usage: %s [--lib | --lib-gen] <ctypes.depend>"
          Sys.argv.(0);
        exit 1
  in
  let path = Sys.argv.(2) in
  match mode with
  | Lib_gen ->
      let modules =
        Sys.readdir "."
        |> Array.to_list
        |> List.filter_map (chop_suffix_opt ~suffix:"_gen.ml")
        |> List.sort String.compare
      in
      print_header ();
      print_generator_stanzas modules
  | Lib_bindings ->
      let deps = read_dependencies path in
      let modules =
        Sys.readdir "."
        |> Array.to_list
        |> List.filter_map (chop_suffix_opt ~suffix:"_bindings.ml")
        |> List.sort String.compare
      in
      print_header ();
      (* Format.printf "(copy_files (alias header_files) (files ../*.h))@.@."; *)
      print_library_stanzas deps modules
  | _ -> assert false
